---
title: "ISDA609 Week 1 Homework"
author: "Daniel Dittenhafer"
date: "August 27, 2015"
output: pdf_document
---
```{r, echo=FALSE}
library(ggplot2)
myTheme <- theme(axis.ticks=element_blank(),  
                  panel.border = element_rect(color="gray", fill=NA), 
                  panel.background=element_rect(fill="#FBFBFB"), 
                  panel.grid.major.y=element_line(color="white", size=0.5), 
                  panel.grid.major.x=element_line(color="white", size=0.5))
```

### Page 8, Problem #10

#### Annuity

* Interest Rate: 1%
* Withdrawl: $1000/month
* Current Value: $50,000

The dynamical system can be modeled using the following equation:

\[a_{n+1} = a_n + 0.01a_n - 1000\]
\[a_0 = 50000\]

The `annuityModel` function, below, defines the basic dynamical system:

```{r}
annuityModel <- function(a_n, i, w)
{
  a_next <- a_n + (a_n * i) - w
  
  return (a_next)
}
```

If we run the model through some iterations, what happens?

```{r}
# Setup variables related to the annuity
a <- 50000
rate <- 0.01
withdrawl <- 1000
# Store results in a data frame.
result <- data.frame(month=c(0), value=c(a))
# Loop through time
for(n in 1:100)
{
  a <- annuityModel(a, rate, withdrawl)
  
  result <- rbind(result, c(n, a))
  
  if(a < 0)
  {
    # End when a_n is less than zero
    break
  }
}

# Update data frame names to be user friendly.
colnames(result) <- c("month", "value")

# show some raw data
head(result)
tail(result)
```

The annuity will run out of money after `r n` months. When the annuity is depleted, the value of \(a_n\) would be `r result$value[n + 1]` if the full withdrawal were allowed. Otherwise \(a_n\) will be 0.

The visualization below shows the graphical representation of the dynamical system.

```{r, echo=FALSE}
plot(result, main="Annuity")
```

### Page 17, Problem #9

```{r}
# Setup the vectors of data
n <- 1:16
speed <- n * 5
a_n <- c(3,6,11,21,32,47,65,87,112,140,171,204,241,282,325,376)
# Compute the delta between a_n and a_n+1
d_an <- c()
d_an[0] <- NA
for(i in 1:length(a_n))
{
  d_an[i] <- a_n[i] - a_n[i - 1] 
}
# Convert to data.frame
d9 <- data.frame(n, speed, a_n, d_an)
```

#### (a) Calculate and plot the change \(\Delta a_n\) versus \(n\). Does the graph reasonably approximate a linear relationship?

The visualization below plots the change in \(a_n\) vs \(n\). As you can see, the graph does reasonably approximate a linear relationship.

```{r, echo=FALSE}
plot(d9[,c("d_an", "n")], main="Change in a_n vs n")
```

#### (b) Based on your conclusions in part (a), find a difference equation model for the stopping distance data. Test your model by plotting the errors in the predicted values against \(n\). Discuss the appropriateness of the model.

First find slope of the estimated difference line:

```{r}
delta_d_an <- max(d9$d_an, na.rm=TRUE)
delta_n <- max(d9$n)
r <-  delta_d_an / delta_n
r
```

Next define a function `stoppingDistanceModel` to wrap the proposed model, run the model over some period of time:

```{r}
# Define the difference equation model
stoppingDistanceModel <- function(n, a, r)
{
    an <- r * n + a
    return(an)
}

m <- c()
m[1] <- 0
for(i in 2:length(a_n))
{
  m[i] <- stoppingDistanceModel(i, m[i-1], r)
}

d9a <- cbind(d9, m)
d9a
```



```{r, echo=FALSE}
d9viz <- ggplot(data=d9a, aes(x=n)) + 
  geom_point(color="blue", aes(y=a_n)) + 
  geom_point(aes(y=m)) + myTheme + 
  labs(title="Model (black) vs Actual (blue)")
d9viz

# Plot the errors in predicted values against n
d9a$err <- d9a$a_n - d9a$m
d9ErrViz <- ggplot(data=d9a, aes(x=n)) + 
  geom_point(color="red", aes(y=err)) + myTheme +
  labs(title="Model Error")
d9ErrViz
```

This is a very crude linear based model. The actual change in not quite linear, which contributes to the error. As larger values of \(n\) are applied, the model error increases steadily. The model works as a rough estimator, but there is definitely room for improvement.

### Page 34, Problem #13

The rumor model from the text is shown below:

\[r_{n+1}=r_n + kr+n(1000 - n)\]

We recreate this model in R code below, in the `rumorModel` function:

```{r}
rumorModel <- function(k, rn, n)
{
  rn1 <- rn + (k * rn * (1000 - n))
  return (rn1)
}

```

Next we define the starting assumptions of \(k=0.001\), and \(r_0=4\), followed by a loop to iterate over the days, \(n\), until all 1000 people have heard the rumor.

```{r}
rnx <- c()
rnx[1] <- 4
k <- 0.001
for(n in 1:100)
{
  rnx[n + 1] <- rumorModel(k, rnx[n], n)
  if(rnx[n+1] > 1000)
  {
    break
  }
}
```

The rumor spread throughout the company after `r n+1` days.

```{r}
# Show number of people who've heard the rumor each day.
rnx
```

```{r, echo=FALSE}
plot(rnx, main = "Spread of a Rumor at Company")
```

### Page 55, Problem #6

First we start with the model from the text:

\[P_{n+1}=P_n-0.1(Q_n-500)\]

\[Q_{n+1}=Q_n+0.2(P_n-100)\]

To find the equilibrum values, where \(X_{n+1} = X_n\), we set both \(X_{n+1}\) and \(X_n\) equal to \(X\):

\[P=P-0.1(Q-500)\]

\[Q=Q+0.2(P-100)\]

And then solve for \(Q\) and \(P\), respectively:

\[0=P-0.1(Q-500)-P\]

\[0=0.1(Q-500)\]

\[0=0.1Q - 50\]

\[50=0.1Q\]

\[Q=500\]



\[0=Q+0.2(P-100)-Q\]

\[0=0.2(P-100)\]

\[0=0.2P-20\]

\[20=0.2P\]

\[P=100\]

These equilibrium values, \(Q=500\) and \(P=100\), make sense as we can see they will zero out the second term in each equation and produce \(X_{n+1} = X_n\) result.

#### a. Does the model make sense intuitively? What is the significance of the constants 100 and 500? Explain the significance of the signs on the constants -0.1 and 0.2.

Referring back to the exercise's write-up, "increasing quantity of the product supplied tends to drive the price down". We see this in the price equation where a Q > 500 will begin reducing the price. Likewise, "a high price for the product in the market attracts more suppliers". Again, we can see this in the quantity equation where P > 100 will increase the quantity supplied. The constants 100 and 500 represent threshold values where the price and quantity respectively change their effect on the others outcome. The signs of the constants -0.1 and 0.2 are key to representing the economic behaviour of more suppliers puts downward pressure on prices, and higher prices encourages more suppliers.

#### b. Test the initial conditions in the following table and predict the long-term behaviour

The table from the text is reproduced below:

  Case X   | Price | Quantity |
 ----------|-------|----------|
  Case A   |  100  |   500    |
  Case B   |  200  |   500    |
  Case C   |  100  |   600    |
  Case D   |  100  |   400    |

The following `R` code contains the price and quantity equations defined in the functions `priceModel` and `quantityModel`. Additionally, a helper function `execModelLoop` is defined to help with the repeated execution of 
the models with the various initial conditions.

```{r}
priceModel <- function(pn, qn)
{
  pnx <- pn - (0.1 * (qn - 500))
  return (pnx)
}

quantityModel <- function(pn, qn)
{
  qnx <- qn + (0.2 * (pn - 100))
  return (qnx)
}

execModelLoop <- function(p0, q0, maxN, caseId)
{
  pnc <- c()
  pnc[1] <- p0
  
  qnc <- c()
  qnc[1] <- q0
  for(n in 1:maxN)
  {
    pnc[n + 1] <- priceModel(pnc[n], qnc[n])
    qnc[n + 1] <- quantityModel(pnc[n], qnc[n])
  }
  
  dfPQ <- data.frame(case=rep_len(caseId, maxN+1), n=1:(maxN+1), pnc, qnc)
  return (dfPQ)
}
```

Case A, from the table, using the equilibrium values. Let's see how that behaves.

```{r}
maxIterations <- 100
# First run the equilibrium values and show result.
caseA <- execModelLoop(100, 500, maxIterations, "Case A")
head(caseA)
```

Case B:

```{r}
# Case B
caseB <- execModelLoop(200, 500, maxIterations, "Case B")
head(caseB)
```

Case C:

```{r}
# Case C
caseC <- execModelLoop(100, 600, maxIterations, "Case C")
head(caseC)
```

Case D:

```{r}
# Case D
caseD <- execModelLoop(100, 400, maxIterations, "Case D")
head(caseD)
```

How do they look graphically?

```{r, echo=FALSE}
dfCases <- data.frame()
dfCases <- rbind(dfCases, caseA)
dfCases <- rbind(dfCases, caseB)
dfCases <- rbind(dfCases, caseC)
dfCases <- rbind(dfCases, caseD)
colnames(dfCases) <- c("Case", "n", "Price", "Quantity")

gCasePrices <- ggplot(data=dfCases, aes(x=n, y=Price)) + 
  geom_line(aes(colour=Case)) + myTheme + 
  labs(title="Price Behaviour of Initial Conditions")
gCasePrices

gCaseQuan <- ggplot(data=dfCases, aes(x=n, y=Quantity)) + 
  geom_line(aes(colour=Case)) + myTheme + 
  labs(title="Quantity Behaviour of Initial Conditions")
gCaseQuan

```

Using the visualizations shown above as a guide, the non-equilibrium initial conditions tested will result in larger and larger oscillations across the equilibrium values, but in an unstable manner which will not converge on any equilibrium.
